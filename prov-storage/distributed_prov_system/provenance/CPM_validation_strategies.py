# change - whole file added in this thesis

from abc import abstractmethod, ABC

from prov.constants import PROV_ATTR_ENTITY, PROV_ATTR_ACTIVITY, PROV_ATTR_AGENT, PROV_ATTR_SPECIFIC_ENTITY, \
    PROV_ATTR_USED_ENTITY, PROV_ATTR_GENERATED_ENTITY, PROV_ATTR_GENERAL_ENTITY
from prov.model import ProvEntity, first, ProvSpecialization, ProvRelation, ProvAttribution, ProvDerivation

from provenance.CPM_helpers import get_prov_generations_usages_attributions_agents
from provenance.constants import BACKWARDS_CONNECTOR_MANDATORY_ATTRIBUTES, CPM_BACKWARD_CONNECTOR, \
    CPM_FORWARD_CONNECTOR, CPM_REFERENCED_META_BUNDLE_ID, CPM_REFERENCED_BUNDLE_ID


class CPMValidator(ABC):

    @abstractmethod
    def check_backward_connectors_attributes(self, connectors):
        """Check whether backward connectors have all needed attributes according to CPM standard

        :param connectors: list of Prov entities - backward connectors
        :returns: bool: true if attributes of all connectors are ok
        """
        pass

    @abstractmethod
    def check_forward_connectors_attributes(self, connectors):
        """Check whether forward connectors have all needed attributes according to CPM standard

        :param connectors: list of Prov entities - forward connectors
        :returns: bool: true if attributes of all connectors are ok
        """
        pass

    @abstractmethod
    def check_cpm_constraints(self, bundle, forward_connectors, backward_connectors, main_activity):
        """Check whether Prov bundle adhere to CPM standard - checks relations between records

        :param bundle: Prov bundle to check
        :param forward_connectors: forward connectors from the bundle
        :param backward_connectors: backward connectors form the bundle
        :param main_activity: main activity of the CPM bundle
        :returns: bool: true if attributes of all connectors are ok
        """
        pass


class CPMValidatorFirst(CPMValidator):

    # added checks - backward connectors  should have all mandatory attributes, forward should have
    # all of have one of them
    def check_backward_connectors_attributes(self, connectors):
        for entity in connectors:
            attribute_ids = [attr_tuple[0] for attr_tuple in entity.extra_attributes]
            for attribute in BACKWARDS_CONNECTOR_MANDATORY_ATTRIBUTES:
                if attribute not in attribute_ids:
                    return False
        return True

    def check_forward_connectors_attributes(self, connectors):
        for entity in connectors:
            attribute_ids = [attr_tuple[0] for attr_tuple in entity.extra_attributes]
            has_optional_attributes = False
            is_missing_some_optional_attribute = False
            for attribute in BACKWARDS_CONNECTOR_MANDATORY_ATTRIBUTES:
                if attribute in attribute_ids:
                    has_optional_attributes = True
                if attribute not in attribute_ids:
                    is_missing_some_optional_attribute = True
            if has_optional_attributes and is_missing_some_optional_attribute:
                return False
        return True

    # added checking of  CPM constraints
    def check_cpm_constraints(self, bundle, forward_connectors, backward_connectors, main_activity):
        (generations, usages, attributions, sender_agents, receiver_agents, specializations, derivations,
         all_relations) = get_prov_generations_usages_attributions_agents(
            bundle)
        backward_connectors_ids = [x.identifier for x in bundle.get_records(ProvEntity) if
                                   x.get_asserted_types() is not None
                                   and CPM_BACKWARD_CONNECTOR in x.get_asserted_types()]
        forward_connectors_ids = [x.identifier for x in bundle.get_records(ProvEntity) if
                                  x.get_asserted_types() is not None
                                  and CPM_FORWARD_CONNECTOR in x.get_asserted_types()]

        # every general forward connector is generated by main activity if it has generation defined or
        # is derived from other forward connector
        for connector in forward_connectors:
            derived_from_fw = False
            connector_generations = [x for x in generations if first(x.get_attribute(PROV_ATTR_ENTITY)) ==
                                     connector.identifier]
            connector_derived_from_relations = [x for x in derivations if
                                                first(x.get_attribute(PROV_ATTR_GENERATED_ENTITY)) ==
                                                connector.identifier]
            connector_specialized = [x for x in specializations if
                                     first(x.get_attribute(PROV_ATTR_SPECIFIC_ENTITY)) ==
                                     connector.identifier]

            if len(connector_generations) == 0 and len(connector_derived_from_relations) == 0 and len(
                    connector.get_attribute(CPM_REFERENCED_BUNDLE_ID)) > 0:
                # check whether the concrete connector is specialized from other forward connector
                if len(connector_specialized) != 1 or \
                        first(connector_specialized[0].get_attribute(
                            PROV_ATTR_GENERAL_ENTITY)) not in forward_connectors_ids:
                    return False, (f"Forward connector [{connector.identifier}] is not general one and "
                                   f"not specialized from other forward connector.")
                continue

            if len(connector_generations) != 1 and len(connector_derived_from_relations) < 1:
                return False, (f"Forward connector [{connector.identifier}] has many generations or is missing one, "
                               f"or is not derived from other connector.")

            if len(connector_generations) == 1 and first(
                    connector_generations[0].get_attribute(PROV_ATTR_ACTIVITY)) != main_activity.identifier:
                return False, f"Forward connector [{connector.identifier}] generated by activity other than main one."

            if len(connector_derived_from_relations) >= 1:
                for derivation in connector_derived_from_relations:
                    if first(
                            derivation.get_attribute(
                                PROV_ATTR_USED_ENTITY)) not in forward_connectors_ids + backward_connectors_ids:
                        return False, (f"Forward connector [{connector.identifier}] derived from entity other than"
                                       f" forward or backward connector.")
                    if first(
                            derivation.get_attribute(PROV_ATTR_USED_ENTITY)) in forward_connectors_ids:
                        derived_from_fw = True

            if not derived_from_fw and len(connector_generations) != 1:
                return False, (f"Forward connector [{connector.identifier}] not generated by main activity "
                               f"and not derived from other forward connector.")

        # every backward connector is used by main activity, it can be in derivation of relationship
        # with other connector
        for connector in backward_connectors:
            derived_from_bw = False
            connector_usages = [x for x in usages if first(x.get_attribute(PROV_ATTR_ENTITY)) ==
                                connector.identifier]
            connector_derived_from_relations = [x for x in derivations if
                                                first(x.get_attribute(PROV_ATTR_USED_ENTITY)) ==
                                                connector.identifier]

            if len(connector_usages) != 1 and len(connector_derived_from_relations) < 1:
                return False, (f"Backward connector [{connector.identifier}] has many usages or is missing one "
                               f"or nothing was derived from it.")

            if len(connector_usages) == 1 and first(
                    connector_usages[0].get_attribute(PROV_ATTR_ACTIVITY)) != main_activity.identifier:
                return False, f"Backward connector [{connector.identifier}] not used by main activity."

            if len(connector_derived_from_relations) >= 1:
                for derivation in connector_derived_from_relations:
                    if (first(
                            derivation.get_attribute(
                                PROV_ATTR_GENERATED_ENTITY)) not in
                            forward_connectors_ids + backward_connectors_ids):
                        return False, (f"Entity other than forward or backward connector derived "
                                       f"from backward connector [{connector.identifier}] .")
                    if first(
                            derivation.get_attribute(PROV_ATTR_GENERATED_ENTITY)) in backward_connectors_ids:
                        derived_from_bw = True

            if not derived_from_bw and len(connector_usages) != 1:
                return False, (f"Backward connector [{connector.identifier}] not used by main activity "
                               f"and no other backward connector derived from it.")

        # every usage by main activity is of backward connector
        main_activity_usages = [x for x in usages if first(x.get_attribute(PROV_ATTR_ACTIVITY)) ==
                                main_activity.identifier]

        for usage in main_activity_usages:
            if first(usage.get_attribute(PROV_ATTR_ENTITY)) not in backward_connectors_ids:
                return False, "Main activity used entity that is not backward connector"

        main_activity_generations = [x for x in generations if first(x.get_attribute(PROV_ATTR_ACTIVITY)) ==
                                     main_activity.identifier]

        for generation in main_activity_generations:
            if first(generation.get_attribute(PROV_ATTR_ENTITY)) not in forward_connectors_ids:
                return False, "Main activity generated entity that is not forward connector"

        # every receiver/sender agent has some forward/backward connector attributed to him
        # in case agent acts as both he has to have at least one connector attributed
        for agent in receiver_agents:
            if agent.identifier not in [first(x.get_attribute(PROV_ATTR_AGENT)) for x in attributions if
                                        first(x.get_attribute(PROV_ATTR_ENTITY)) in forward_connectors_ids] \
                    and (
                    agent not in sender_agents and agent.identifier not in
                    [first(x.get_attribute(PROV_ATTR_AGENT)) for
                     x in attributions if
                     first(x.get_attribute(
                         PROV_ATTR_ENTITY)) in backward_connectors_ids]):
                return False, "Receiver agent is not attributed to forward connector"

        for agent in sender_agents:
            if agent.identifier not in [first(x.get_attribute(PROV_ATTR_AGENT)) for x in attributions if
                                        first(x.get_attribute(PROV_ATTR_ENTITY)) in backward_connectors_ids] \
                    and (
                    agent not in receiver_agents and agent.identifier not in
                    [first(x.get_attribute(PROV_ATTR_AGENT)) for
                     x in attributions if
                     first(x.get_attribute(
                         PROV_ATTR_ENTITY)) in forward_connectors_ids]):
                return False, "Sender agent is not attributed to backward connector"

        # check also reverse - every backward connector has agent
        for connector in backward_connectors:
            if connector.identifier not in [first(x.get_attribute(PROV_ATTR_ENTITY)) for x in attributions if
                                            first(x.get_attribute(PROV_ATTR_AGENT)) in [x.identifier for x in
                                                                                        sender_agents]]:
                return False, "Backward connector does not have agent attributed"

        # similar check for forward connectors but only of specialized ones
        for connector in forward_connectors:
            connector_specializations = [x for x in specializations if
                                         first(x.get_attribute(PROV_ATTR_SPECIFIC_ENTITY)) ==
                                         connector.identifier]
            if len(connector_specializations) == 1:
                if connector.identifier not in [first(x.get_attribute(PROV_ATTR_ENTITY)) for x in attributions if
                                                first(x.get_attribute(PROV_ATTR_AGENT)) in [x.identifier for x in
                                                                                            receiver_agents]]:
                    return False, "Forward connector does not have agent attributed"

        # check for relations between connectors - derivation only possible from connectors
        all_conns_ids = forward_connectors_ids + backward_connectors_ids
        for connector in forward_connectors:
            connector_relations = [x for x in all_relations if
                                   connector.identifier in [qname for _, qname in x.formal_attributes[:2]]]
            for relation in connector_relations:
                element_1, element_2 = [qname for _, qname in relation.formal_attributes[:2]]
                if isinstance(relation, ProvDerivation) and (
                        element_1 not in all_conns_ids or element_2 not in all_conns_ids):
                    return False, "Forward connector is related to entity that is not connector by derivation"

        for connector in backward_connectors:
            connector_relations = [x for x in all_relations if
                                   connector.identifier in [qname for _, qname in x.formal_attributes[:2]]]
            for relation in connector_relations:
                element_1, element_2 = [qname for _, qname in relation.formal_attributes[:2]]
                if isinstance(relation, ProvDerivation) and (
                        element_1 not in all_conns_ids or element_2 not in all_conns_ids):
                    return False, "Backward connector is related to entity that is not connector by derivation"

        # check that the connectors do not reference this bundle
        meta_bundle_id = first(main_activity.get_attribute(CPM_REFERENCED_META_BUNDLE_ID))
        bundle_id = bundle.identifier
        for connector in forward_connectors + backward_connectors:
            if first(connector.get_attribute(CPM_REFERENCED_BUNDLE_ID)) == bundle_id:
                return False, f"Forward or backward connector references this bundle [{bundle_id}]."
            if first(connector.get_attribute(CPM_REFERENCED_META_BUNDLE_ID)) == meta_bundle_id:
                return False, f"Forward or backward connector references this meta bundle [{meta_bundle_id}]."
        # add check for relations between bb and ds in future
        return True, "ok"
